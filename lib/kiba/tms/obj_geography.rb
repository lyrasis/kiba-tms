# frozen_string_literal: true

module Kiba
  module Tms
    module ObjGeography
      extend Dry::Configurable
      module_function

      # @return [Array<Symbol>] unmigratable fields removed by default
      setting :delete_fields,
        default: %i[keyfieldssearchvalue],
        reader: true

      # @return [Array<Symbol>] ID and other always-unique fields not treated as
      #   content for reporting, etc.
      def non_content_fields
        %i[objgeographyid objectid geocode primarydisplay]
      end
      extend Tms::Mixins::Tableable

      # TMS GeoCode values that will be mapped to place authority-controlled
      #   fields in CS
      # May be a list of selected GeoCode values, :all, or :none
      setting :controlled_types,
        default: [],
        reader: true

      # Lambda function passed to transforms in order to conditionally extract
      #   info to separate note fields and delete note data strings from values
      #   to be included in authority term values
      # The effect is that a row will not be normalized for authority extraction
      #   if it isn't mapping to a place authority-controlled field
      def controlled_type_condition
        ->(row) do
          types = Tms::ObjGeography.controlled_types
          return true if types == :all
          return false if types == :none

          types.any?(row[:geocode])
        end
      end

      # Hierarchical order of the :country and :nation fields, ordered
      #   narrow-to-broad. To omit one or both from the overall hierarchy,
      #   remove from this setting.
      setting :country_nation_order,
        default: %i[country nation],
        reader: true

      # Content fields whose values will be treated hierarchically. Should be
      #   be ordered narrow-to-broad. For example, with the default values,
      #   you may get a hierarchical authority term like:
      #   Durham -- Durham (county) -- North Carolina -- USA -- North America
      #
      # We can optionally build a Place authority hierarchy involving values
      #   in these fields
      #
      # :subregion is omitted because, based on client data reviews, this field
      #   is used to describe various levels of subregion, such that it is
      #   impossible to place the values at any one place in the hierarchy. For
      #   example, "Appalachia, Southern" would be a subregion of Appalachia,
      #   while being broader than individual state. Conversely, "Piedmont" or
      #   "Sand Hills" might be assigned as subregions of North Carolina, thus
      #   narrower than state.
      # :culturalregion is omitted for the same reasons as :subregion
      setting :hierarchy_fields,
        default: %i[locus building locale township city county
                    state river politicalregion region],
        reader: true,
        constructor: ->(value) do
          value << country_nation_order
          value << :continent
          value.flatten
        end

      # Whether to remove parts of terms indicating proximity (near, or close
      #   to) from the values that will become authority terms, moving these
      #   strings to a separate :proximity field, which can be merged in as
      #   role or note field value associated with a particular use of the
      #   term in an object record.
      #
      # You may want this set to `false` if:
      #
      # - You want to have separate authority terms for "Paris" and
      #   "near Paris"; or
      # - Your type_to_object_field_mapping includes CS object fields
      #   without associated role, type, or note field per place value
      setting :proximity_as_note,
        default: true,
        reader: true

      # Same as `:proximity_as_note`, but for parts of terms indicating
      #   uncertainty, like "(?)", "possibly", or "probably"
      setting :uncertainty_as_note,
        default: true,
        reader: true

      # Project-specific regular expression patterns matching non-proximity or
      #   uncertainty strings that should be removed from authority term values,
      #   and included in a note when term is used in object record
      setting :misc_note_patterns,
        default: [],
        reader: true,
        constructor: ->(value) do
          value.map{ |pattern| [pattern, "patternmatch"] }
            .to_h
        end

      # The note fields that may be generated by the three above settings. These
      #   fields contain values that must be removed for authority extraction
      #   and processing
      setting :derived_note_fields,
        default: [],
        reader: true,
        constructor: ->(value) do
          value << :proximity if proximity_as_note
          value << :uncertainty if uncertainty_as_note
          value << :misc_note unless misc_note_patterns.empty?
          value
        end

      # Custom transform classes to clean data in the table at the end of the
      #   initial prep process. Transforms will be carried out in order listed.
      setting :prep_cleaners,
        default: [
          # When a whole field value is wrapped in parentheses, the outer
          #   parentheses are removed. "(This)" becomes "This", while
          #   "New York (NY)" would be left the same.
          Tms::Transforms::ObjGeography::RemoveFullParentheticals
        ],
        reader: true

      # -----------------------------------------------------------------------
      # Proximity and uncertainty pattern-related settings
      # -----------------------------------------------------------------------
      #
      # These are only used if we are treating :proximity_as_note and/or
      #   :uncertainty_as_note. If so, these are used for two purposes:
      # - String segments matching the patterns are deleted from any values in
      #   which they appear when we are extracting the unique values from which
      #   to create authority terms
      # - If the pattern (left side of =>) matches a field value in a row, the
      #   term (from right side of =>) is added to a :proximity, and/or
      #   :uncertainty field in that row. These field values can then be used
      #   to qualify specific uses of the now generic, authorized place term (in
      #   role, type, or note field associated with field into which the place
      #   value is mapped.
      #
      # - default - common patterns expected across datasets
      # - removed - allows us to remove any default pattern that is
      #   problematic for the project data
      # - custom - allows us to override the term added to note for a given
      #   default pattern, and also add new patterns specific to project
      #   data set
      #
      # DATA LOSS WARNING:
      # If proximity/uncertainty indicators are extracted to notes, but the
      #   place values with which they are associated are mapped to a CS
      #   place authority-controlled field which does not have an associated
      #   role, type, or note field for each value, the specific
      #   proximity and/or uncertainty indicators will be lost in the migration
      #
      # IMPLEMENTATION NOTES:
      # If both proximity and uncertainty are being treated as notes, make sure
      #   that indicator terms have been mapped to :proximity and :uncertainty
      #   fields for BOTH before any deleting/cleaning any patterns from the
      #   field values. Reason: Deleting matching proximity patterns may cause
      #   uncertainty patterns not to match, and vice versa.
      #
      # To redefine an existing default pattern with a different term to be
      #   merged into notes, just add it to the custom pattern setting; you do
      #   not need to add it to removed AND custom pattern settings.
      setting :default_proximity_patterns,
        default: {
          /\(above\)/=>"above",
          /^near /=>"near",
          /\(near\??\)/i=>"near",
          /, near/=>"near",
          /\(outside\)/=>"exterior",
          /\(head of\??\)/=>"head of",
          /\(south of\??\)/=>"south of"
        },
        reader: true

      setting :removed_proximity_patterns,
        default: [],
        reader: true

      setting :custom_proximity_patterns,
        default: {},
        reader: true

      setting :default_uncertainty_patterns,
        default: {
          /\(\?\)/=>"uncertain",
          /\? *$/=>"uncertain",
          / \? /=>"uncertain",
          / *\(probably\) */=>"probable",
          /^probably /=>"probable"
        },
        reader: true

      setting :removed_uncertainty_patterns,
        default: [],
        reader: true

      setting :custom_uncertainty_patterns,
        default: {},
        reader: true

      # Derives actual proximity patterns from default, removed, and custom
      #   settings
      def proximity_patterns
        abstract_patterns("proximity")
      end

      # Derives actual uncertainty patterns from default, removed, and custom
      #   settings
      def uncertainty_patterns
        abstract_patterns("uncertainty")
      end

      # Derives all patterns to be deleted from authority term values, from
      #  proximity, uncertainty, and misc_note settings
      def delete_patterns
        base = [misc_note_patterns.keys]
        base << proximity_patterns.keys if proximity_as_note
        base << uncertainty_patterns.keys if uncertainty_as_note
        base << /\(\)/ unless base.empty?
        base.flatten
      end

      def abstract_patterns(type)
        return {} unless send("#{type}_as_note".to_sym)

        default = send("default_#{type}_patterns".to_sym)
        removed = send("removed_#{type}_patterns".to_sym)
        custom = send("custom_#{type}_patterns".to_sym)

        base = if removed.empty?
                 default
               else
                 newdefault = default.dup
                 removed.each do |pattern|
                   newdefault.delete(pattern)
                 end
                 newdefault
               end
        custom.keys.each do |pattern|
          next unless base.key?(pattern)

          base.delete(pattern)
        end
        custom.merge(base)
      end
      private_class_method :abstract_patterns
    end
  end
end
